"""This module helps identifying the timezone ids and where they differ.

The algorithm: We use the tzname and the utcoffset for each hour from
1970 - 2030.
We make a big map.
If they are equivalent, they are equivalent within the time that is mostly used.

You can regenerate the information from this module.
"""
from __future__ import annotations

from collections import defaultdict
from datetime import datetime, timedelta, tzinfo
from itertools import chain
from pathlib import Path
from pprint import pprint
from zoneinfo import ZoneInfo, available_timezones


def check(dt, tz:tzinfo):
    return (dt, tz.utcoffset(dt), tz.tzname(dt))

def main(start=datetime(1970, 1, 1), end=datetime(2030, 1, 1)):
    """Generate the module content."""
    dts = []
    dt = start
    while dt <= end:
        dts.append(dt)
        dt += timedelta(hours=1)

    def checks(tz:tzinfo) -> tuple:
        return tuple(check(dt, tz) for dt in dts)

    id2tzid = {}

    dtids2tzids = defaultdict(tuple) # checks -> tzids
    tzids = list(sorted(available_timezones()))
    print("Press Control+C for partial computation.")
    tzs = list(map(ZoneInfo, tzids))
    try:
        for i, tzid in enumerate(sorted(tzids)):
            dtids2tzids[checks(tzs[i])] += (tzid,)
            print(f"{i}/{len(tzids)}")
    except KeyboardInterrupt:
        pass

    print("The following ids are equivalent")
    for tzids in dtids2tzids.values():
        print(tzids)


    # def generate_count(ids_list:list[list]):
    #     """-> dt_id -> count"""
    #     counts = defaultdict(int)
    #     for ids in ids_list:
    #         for dt_id in ids:
    #             counts[dt_id] += 1
    #     return counts

    print("counting tzids for dtids")
    # datetime -> dtid -> tzids
    dates : list[datetime] = []
    lookup :dict[datetime, dict[tuple, list[str]]]= defaultdict(dict)
    tzids2dtids : dict[tuple, tuple] = {
        v:k for k, v in dtids2tzids.items()
    }
    # uniquedtid2tzids = dtid -> [tzids, ...]
    n = len(dtids2tzids)
    uniquedtid2tzids : dict[tuple, list[tuple|str]] = defaultdict(list)
    for i, (dtids, tzids) in enumerate(dtids2tzids.items()):
        for dtid in dtids:
            uniquedtid2tzids[dtid].append(tzids)
        print(f"{i+1}/{n}")
    print("finding identifying ids")
    n = len(uniquedtid2tzids.items())
    p = 0
    for i, (dtid, tzids) in enumerate(list(uniquedtid2tzids.items())):
        if len(tzids) == 1:
            uniquedtid2tzids[dtid] = tzids[0]
        else:
            del uniquedtid2tzids[dtid]
        p_ = int((i+1)/n*100)
        if p_ != p:
            p = p_
            print(f"{p}%")
    # uniquedtid2tzids = dtid -> tuple[tzids]
    dt2uniquedtids = defaultdict(set)
    for dtid in uniquedtid2tzids:
        dt2uniquedtids[dtid[0]].add(dtid)

    print("Computing tree to find tzids")
    n = len(dt2uniquedtids)
    p = 0
    while dt2uniquedtids:
        dt = min(dt2uniquedtids)
        uniquedtids = dt2uniquedtids.pop(dt)
        dates.append(dt)
        for uniquedtid in uniquedtids:
            tzids = uniquedtid2tzids[uniquedtid]
            lookup[dt][uniquedtid[1:]] = tzids
            for dtid in tzids2dtids[tzids]:
                dtids_to_shrink = dt2uniquedtids[dtid[0]]
                dtids_to_shrink-= {dtid}
                if not dtids_to_shrink:
                    del dt2uniquedtids[dtid[0]]
        p_ = int(100 - len(dt2uniquedtids)/n*100)
        if p_ != p:
            p = p_
            print(f"{p}%")

    file = Path(__file__).parent / "equivalent_timezone_ids_result.py"
    print(f"The result is written to {file}.")
    lookup = dict(lookup)
    print("lookup = ", end="")
    pprint(lookup)
    with file.open("w") as f:
        f.write(f"'''This file is automatically generated by {Path(__file__).name}'''\n")
        f.write("import datetime\n\n")
        f.write(f"lookup = ")
        pprint(lookup, stream=f)
        f.write("\n\n__all__ = ['lookup']\n")


    # print("Calculating most identifying date ids")
    # count = generate_count(dtids2tzids)
    # look = [(set(k), v) for k, v in dtids2tzids.items()]
    # ones = {k for k, v in count.items() if v == 1}
    # print("Calculating best dates to check")
    # date_count = defaultdict(int)
    # for dt_id in ones:
    #     date_count[dt_id[0]] += 1
    # best_dates = sorted(date_count, key=date_count.__getitem__)
    # print("dates:")
    # for date in reversed(best_dates):
    #     for tzid, tz in zip(tzids, tzs):
    #         for 
    # while look:
    #         for tz in tzs:
    #             if  in ones:
                    
    #         for i, (k, tzids) in enumerate(look):
    #             if dt_id in k:
    #                 result[dt_id] = tzids
    #                 look.pop(i)
    #                 ones -= k
    #                 break
    #         break
    # print("Clearly identifying:")
    # pprint(result)



    # #
    # # If we always take those with the count close to half of them,
    # # we can create a binary decision tree.
    # #
    # def generate_tree(ids:list[list[list, list, list[str]]]):
    #     """Returns ((key), YES, NO)

    #     YES and NO are one of
    #     - (check, YES, NO)
    #     - [TZID]
    #     """
    #     print(f"generate_tree -> {len(m)}")
    #     if len(m) == 1:
    #         return m[list(m)[0]]
    #     half = len(m) / 2
    #     for dt_id, count in counts.items():
    #         if count == 1:
    #             ones.append(dt_id)
    #     # find count closest to half
    #     best_check = min(counts, key=lambda check: abs(counts[check] - half))
    #     yes = {}
    #     no = {}
    #     for cs, v in m.items():
    #         if best_check in cs:
    #             yes[cs] = v
    #         else:
    #             no[cs] = v
    #     return (
    #         best_check,
    #         generate_tree(yes),
    #         generate_tree(no)
    #     )

    # start = [] # [more than once, once, tzids]
    # counts = generate_count(m)
    # for ids, tzids in m.items():
    #     ones = []
    #     more = []
    #     for dt_id in ids:
    #         if counts[dt_id] == 1:
    #             ones.append(dt_id)
    #         else:
    #             more.append(dt_id)
    #         start.append([more, ones, tzids])

    # tree = generate_tree(start, [])
    # pprint(tree)

# def tzids_from_tzinfo(tzinfo: tzinfo) -> tuple[str]:
#     """Retrieve the timezone ids from the tzinfo object.

#     Some of them might be equivalent, some of them are not.
#     """
#     if hasattr(tzinfo, 'zone'):
#         return (tzinfo.zone,)  # pytz implementation
#     if hasattr(tzinfo, 'key'):
#         return (tzinfo.key,)  # ZoneInfo implementation
#     if not _tzname_to_tzid:
#         for tzid in :
#             _tzname_to_tzid[_identify_tzinfo(ZoneInfo(tzid))] += (tzid,)
#     return _tzname_to_tzid.get(_identify_tzinfo(tzinfo), ())


def tzinfo2tzids(tzinfo: tzinfo) -> tuple[str]:
    """We return the tzids for a certain tzinfo object.

    With different datetimes, we match
    (tzinfo.utcoffset(dt), tzinfo.tzname(dt))

    If we could identify the timezone, you will receive a tuple
    with at least one tzid. All tzids are equivalent which means
    that they describe the same timezone.

    You should get results with any timezone implementation if it is known.
    This one is especially useful for dateutil.

    In the following example, we can see that the timezone Africa/Accra
    is equivalent to many others.

    >>> import zoneinfo
    >>> from icalendar.timezone.equivalent_timezone_ids import tzinfo2tzids
    >>> tzinfo2tzids(zoneinfo.ZoneInfo("Africa/Accra"))
    ('Africa/Abidjan', 'Africa/Accra', 'Africa/Bamako', 'Africa/Banjul', 'Africa/Conakry', 'Africa/Dakar')
    """
    try:
        from equivalent_timezone_ids_result import lookup # type: ignore
    except ImportError:
        from icalendar.timezone.equivalent_timezone_ids_result import lookup
    for dt in sorted(lookup):
        _, utcoffset, tzname = check(dt, tzinfo)
        tzids = lookup[dt].get((utcoffset, tzname), ())
        if tzids:
            return tzids
    return ()


__all__ = ["main", "tzinfo2tzids"]

if __name__ == "__main__":
    main()